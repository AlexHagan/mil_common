#!/usr/bin/python

from __future__ import division

import math
import sys
import traceback

import numpy

import rosbag


def remove_mean(x):
    x = numpy.array(x)
    return x - numpy.mean(x)

def remove_mean_cov(cov_with_bias):
    n = cov_with_bias.shape[0]
    A = numpy.eye(n) - 1/n*numpy.ones((n, n))
    return A.dot(cov_with_bias).dot(A.T)

def logP(cov, x, mean=None):
    k = len(x)
    assert cov.shape == (k, k)
    if mean is None:
        mean = numpy.zeros(k)
    try:
        covinv = numpy.linalg.inv(cov)
    except:
        return -1e3000
    a = -1/2 * math.log((2*math.pi)**k*numpy.linalg.det(cov)) - \
        1/2 * (x - mean).T.dot(covinv).dot(x - mean)
    b = -k/2 * math.log(4 * math.pi) - 1/2 * math.log(numpy.linalg.det(cov))
    return a, a - b

if 0:
    prex = [1, 2, 3]
    precov = numpy.diag([(1+i)**2 for i in xrange(3)])
    
    x = remove_mean(prex)
    cov = remove_mean_cov(precov)
    print x
    print cov
    print 'error' #print logP(cov, x)
    
    print
    
    x2 = x[:-1]
    cov2 = cov[:-1, :-1]
    print x2
    print cov2
    print logP(cov2, x2)
    
    print
    
    x3 = x[1:]
    cov3 = cov[1:, 1:]
    print x3
    print cov3
    print logP(cov3, x3)


print 'loading'
with rosbag.Bag(sys.argv[1], 'r') as f:
    points = [msg.satellites for topic, msg, t in f if topic == sys.argv[2]]
print 'loaded', len(points), 'points'

import random
points = random.sample(points, min(len(points), 100000))
print 'loaded', len(points), 'points'

def score(a, b):
    print 'a, b:', a, b

    def stddev_of_dopplervel_minus_bias(cn0):
        return a/(10**(cn0/10))**b
    res = 0
    res2 = 0
    for point in points:
        prex = numpy.array([
            sat.velocity_plus_drift
        for sat in point])
        precov = numpy.diag([
            stddev_of_dopplervel_minus_bias(sat.cn0)**2
        for sat in point])
        
        x = remove_mean(prex)
        cov = remove_mean_cov(precov)
        
        #print x
        #print cov
        lp, lp2 = logP(cov[:-1, :-1], x[:-1])
        #print lp
        
        res += lp
        res2 += lp2
    res /= len(points)*111
    res2 /= len(points)
    print 'score:', res
    print 'score2:', math.exp(res2)
    print
    return res

guess = 9.5520234742, 0.556152922353 # score: 0.045083156399 from random still
guess = 10, 0.318319 # guess
#guess = 20.5564182949, 0.691171572741 # score: 0.0339504325904 from min

if __name__ == '__main__':
    import scipy.optimize
    
    print scipy.optimize.minimize(lambda (a, b): -score(a, b), guess)

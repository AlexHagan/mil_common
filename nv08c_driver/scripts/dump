#!/usr/bin/python

from __future__ import division

import math
import struct

import numpy

import roslib
roslib.load_manifest('nv08c_driver')

import rospy
from std_msgs.msg import String, Header
from geometry_msgs.msg import Vector3, Point, PointStamped

from rawgps_common import gps, glonass, bitstream
from rawgps_common.msg import Measurements, Satellite

from nv08c_driver.msg import Packet, PacketSet

rospy.init_node('dump', anonymous=True)

gps_pub = gps.GPSPublisher(rospy.get_param('~frame_id'))

def cb(msg):
    if msg.id == 0xf5:
        utc_t_ms, week, gpsutc, glonassutc, timecorr = struct.unpack('<dHddb', msg.data[:27])
        utc_t = gps.Time(week, utc_t_ms/1000)
        gps_t = utc_t + gpsutc/1000
        glonass_t = utc_t + glonassutc/1000
        
        print utc_t_ms
        print utc_t, gps_t
        
        import time
        print (utc_t - gps.Time(0, time.time()))/gps.week_length
        
        assert len(msg.data[27:]) % 30 == 0
        sats = []
        for i in xrange(len(msg.data[27:]) // 30):
            d = msg.data[27+30*i:27+30*i+30]
            (sig_type, sat_num, carrier_num, snr,
                carrier_phase, pseudo_range, doppler_freq,
                flags, _reserved) = struct.unpack('<BBbBdddBB', d)
            assert flags & 0x01
            if not flags & 0x02:
                pseudo_range = doppler_freq = None
            if not flags & 0x08:
                carrier_phase = None
            if not flags & 0x10:
                pseudo_range = None
                doppler_freq = None
            
            if sig_type == 0x01:
                # glonass support was included in the past, look in history
                pass
            elif sig_type == 0x02:
                if flags & 0x20:
                    print sat_num, 'half cycle ambiguity!'
                sats.append(dict(
                    prn=sat_num,
                    cn0=snr,
                    pseudo_range=pseudo_range * 1e-3 * gps.c if pseudo_range is not None else None,
                    carrier_cycles=carrier_phase,
                    doppler_freq=doppler_freq,
                ))
            elif sig_type == 0x04:
                print sat_num, carrier_num, 'SBAS!'
        
        gps_pub.handle_raw_measurements(msg.header.stamp, gps_t, sats, math.floor(100*gps_t.TOW+0.5)/10) # receivers appear to align roughly to 0.1 second intervals of GPS time
    elif msg.id == 0x88:
        lat, lon, alt, err, t, week, lat_vel, lon_vel, alt_vel, dev, status = struct.unpack('<dddf10shdddfB', msg.data)
        #print 'PVT', math.degrees(lat), math.degrees(lon), alt, err, None, week, lat_vel, lon_vel, alt_vel, dev, status
        #gps_pub.handle_pos_estimate(msg.header.stamp, gps.ecef_from_latlongheight(lat, lon, alt))
    elif msg.id == 0xf6:
        x, y, z, x_err, y_err, z_err, flags = struct.unpack('<ddddddB', msg.data)
        #print 'GCA', x, y, z, x_err, y_err, z_err, flags
    elif msg.id == 0x70:
        channels, description, serial, res1, res2, res3, res4 = struct.unpack('<B21sI21sI21sI', msg.data)
        #print 'VER', channels, description, serial, res1, res2, res3, res4
    elif msg.id == 0x4a:
        a0, a1, a2, a3, b0, b1, b2, b3, reliable = struct.unpack('<ffffffffB', msg.data)
        #print 'ION', a0, a1, a2, a3, b0, b1, b2, b3, reliable
        if reliable:
            ionospheric_model = gps.IonosphericModel([a0, a1, a2, a3], [b0, b1, b2, b3])
    elif msg.id == 0x4b:
        A1, A0, t_ot, WN_t, dt_LS, WN_LSF, DN, dt_LSF, reliable, NA, tau_C, glonass_reliable = struct.unpack('<ddIHhHHhBHdB', msg.data)
        #print 'TSP', A1, A0, t_ot, WN_t, dt_LS, WN_LSF, DN, dt_LSF, reliable, NA, tau_C, glonass_reliable
    elif msg.id == 0xe7:
        (data_type,), value = struct.unpack('<B', msg.data[:1]), msg.data[1:]
        #print 'AOP', data_type, value.encode('hex')
    elif msg.id == 0xf7:
        sat_type, sat_num = struct.unpack('<BB', msg.data[:2])
        if sat_type == 1: # GPS
            Crs, Dn, M0, Cuc, E, Cus, SqrtA, Toe, Cic, Omega0, Cis, I0, Crc, W, OmegaR, Ir, Tgd, Toc, Af2, Af1, Af0, URA, IODE, IODC, CodeL2, L2_Pdata_flag, WeekN = struct.unpack('<ffdfdfddfdfdfdddfdfffHHHHHH', msg.data[2:])
            #print 'EPH', sat_num, Crs, Dn, M0, Cuc, E, Cus, SqrtA, Toe, Cic, Omega0, Cis, I0, Crc, W, OmegaR, Ir, Tgd, Toc, Af2, Af1, Af0, URA, IODE, IODC, CodeL2, L2_Pdata_flag, WeekN
            #eph = MyEphemeris()
            #eph.C_rs, eph.delta_n, eph.M_0, eph.C_uc, eph.e, eph.C_us, eph.sqrt_A, eph.t_oe, eph.C_ic, eph.omega_0, eph.C_is, eph.i_0, eph.C_rc, eph.omega, eph.omega_dot, eph.IDOT, eph.T_GD, eph.t_oc, eph.a_f2, eph.a_f1, eph.a_f0, eph.URA, eph.IODE, eph.IODC = Crs, Dn*1000, M0, Cuc, E, Cus, SqrtA, Toe/1000, Cic, Omega0, Cis, I0, Crc, W, OmegaR*1000, Ir*1000, Tgd/1000, Toc/1000, Af2*1000, Af1, Af0/1000, URA, IODE, IODC
            #print sat_num, eph
            #print eph.predict(0)
            #ephs[('gps', sat_num)] = eph
        elif sat_type == 2: # GLONASS
            carrier, X, Y, Z, Vx, Vy, Vz, Ax, Ay, Az, t_b, gamma_n, tau_n, E_n = struct.unpack('<bddddddddddffH', msg.data[2:])
            eph = glonass.Ephemeris(t_b/1e3, X, Y, Z, Vx*1e3, Vy*1e3, Vz*1e3, Ax*1e6, Ay*1e6, Az*1e6, gamma_n, tau_n*1e-3)
            #print eph.predict(0)
            #ephs[('glonass', sat_num, carrier)] = eph
            #print 'GPH', eph
        else:
            print 'unknown sat_type', sat_type
    elif msg.id == 0x5d:
        number_of_sats, = struct.unpack('<B', msg.data[:1])
        #print 'Atmospheric corrections:'
        #for i in xrange(number_of_sats):
            #system, number, tropo_delay, iono_delay, reserved = \
            #    struct.unpack('<BBfff', msg.data[1+14*i:1+14*(i+1)])
            #print system, number, tropo_delay, iono_delay, reserved
            #should[3-system, number] = tropo_delay, iono_delay
    elif msg.id == 0xe5:
        number_of_blocks, = struct.unpack('<B', msg.data[:1]); pos = 1
        for i in xrange(number_of_blocks):
            channel, sat_type, sat_number, time = struct.unpack('<BBBI', msg.data[pos:pos+7]); pos += 7
            if sat_type == 1: # GLONASS
                subframe = msg.data[pos:pos+12]; pos += 12
            elif sat_type == 2: # GPS
                subframe = msg.data[pos:pos+40]; pos += 40
                
                subframe = struct.pack('>10I', *struct.unpack('<10I', subframe))
                
                bs = bitstream.BitStream(subframe)
                res = ''
                for i in xrange(10):
                    bs.read(2)
                    for j in xrange(3):
                        res += chr(bs.read(8))
                    bs.read(6)
                assert bs.at_end()
                
                gps_pub.handle_subframe(msg.header.stamp, sat_number, res)
            elif sat_type == 4: # SBAS
                subframe = msg.data[pos:pos+32]; pos += 32
            else:
                assert False, sat_type
        assert pos == len(msg.data)
    else:
        print 'unknown message:', hex(msg.id), msg.data.encode('hex'), len(msg.data)

rospy.Subscriber('nv08c_serial/ephemeral', Packet, cb)
rospy.Subscriber('nv08c_serial/persistent', PacketSet, lambda packet_set: map(cb, packet_set.packets))

rospy.spin()

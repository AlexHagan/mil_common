#!/usr/bin/python

from __future__ import division

import struct

import numpy

import roslib
roslib.load_manifest('skytraq_driver')
import rospy
from std_msgs.msg import Header
from geometry_msgs.msg import Vector3, PointStamped, Point

from rawgps_common import gps, bitstream
from rawgps_common.msg import Measurements, Satellite
from skytraq_driver import protocol
from skytraq_driver.msg import SerialPacket


class Handlers(object):
    def __init__(self, frame_id):
        self.frame_id = frame_id
        
        self.ionospheric_model = None
        self.last_meas_time = None
        self.position = None
        self.ephemerises = {}
        self.pub = rospy.Publisher('gps', Measurements)
        self.pos_pub = rospy.Publisher('~pos', PointStamped)
    
    def gps_ephemeris_data(self, data, stamp):
        sv, = struct.unpack('>H', data[0:2])
        if all(x == '\x00' for x in data[3:]):
            return
        
        eph = gps.Ephemeris(
            data[2+1+28*0:2+1+28*0+27],
            data[2+1+28*1:2+1+28*1+27],
            data[2+1+28*2:2+1+28*2+27],
        )
        assert len(data) == 2+1+28*2+27, len(data)
        del data
        
        #print
        #print sv
        #for k, v in eph.__dict__.iteritems():
        #    print k, repr(v)
        #print
        '''
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        def inertial_from_ecef((x, y, z), t):
            w = -omega_dot_e * t
            return (
                cos(w)*x + sin(w)*y,
            -sin(w)*x + cos(w)*y,
                z,
            )
        data = [inertial_from_ecef(eph.predict(eph.t_oe + i*100), i*100) for i in xrange(216*16//10)]
        data.append((0, 0, 0))
        ax.scatter(*zip(*data))
        plt.show()
        '''
        
        #a = eph.predict(eph.t_oe)
        #print math.sqrt(a[0]**2 + a[1]**2 + a[2]**2)
        
        self.ephemerises[sv] = eph
    
    def ack(self, data, stamp):
        pass
    
    def sv_ch_status(self, data, stamp):
        pass
    
    def meas_time(self, data, stamp):
        IOD, WN, TOW_ms, measurement_period_ms = struct.unpack('>BHIH', data)
        self.last_meas_time = IOD, gps.Time(WN, TOW_ms*1e-3)
    
    def raw_meas(self, data, stamp):
        iod, nmeas = struct.unpack('>BB', data[0:2])
        assert len(data) == 2+nmeas*23
        measurements = [struct.unpack('>BBddfB', data[2+i*23:2+i*23+23])
            for i in xrange(nmeas)]
        
        if self.last_meas_time is None or self.last_meas_time[0] != iod:
            print "IOD didn't match!"
            return
        t = self.last_meas_time[1]
        
        #print nmeas, 'SATELLITES'
        if self.position is None:
            print '   ', 'NO FIX'
            return
        
        msg = Measurements(
            header=Header(
                stamp=stamp,
                frame_id=self.frame_id,
            ),
            satellites=[],
        )
        #print
        #print
        #print
        #print
        #print
        #print
        for prn, cn0, pseudorange, acc_carrier_cycle, doppler_freq, status in measurements:
            (pseudorange_avail, doppler_freq_avail, acc_carrier_cycle_avail,
                cycle_slip_possible, integration_time_greater_10ms) = [
                bool(status & 2**i) for i in xrange(5)]
            if not pseudorange_avail:
                pseudorange = None
            if not doppler_freq_avail:
                doppler_freq = None
            if not acc_carrier_cycle_avail:
                acc_carrier_cycle = None
            
            if doppler_freq is None:
                print 'no doppler frequency, dropping', prn
                continue
            
            if prn not in self.ephemerises:
                #print 'no ephemeris, dropping', prn
                continue
            eph = self.ephemerises[prn]
            if not eph.is_healthy():
                print 'unhealthy, dropping', prn
                continue
            
            sat_msg = gps.generate_satellite_message(prn, eph, cn0, t, pseudorange, acc_carrier_cycle, doppler_freq, self.position, self.ionospheric_model)
            if sat_msg is not None:
                msg.satellites.append(sat_msg)
        #print len(msg.satellites), 'GOOD SATELLITES'
        self.pub.publish(msg)
    
    def rcv_state(self, data, stamp):
        iod, navigation_state, wn, tow, ecef_x, ecef_y, ecef_z, ecef_dx, ecef_dy, ecef_dz, clock_bias, clock_drift, gdop, pdop, hdop, vdop, tdop = struct.unpack('>BBHddddfffdffffff', data)
        del data
        #print locals()
        
        self.position = numpy.array([ecef_x, ecef_y, ecef_z])
        
        self.pos_pub.publish(PointStamped(
            header=Header(
                stamp=stamp,
                frame_id='/ecef',
            ),
            point=Point(ecef_x, ecef_y, ecef_z),
        ))
    
    def subframe(self, data, stamp):
        PRN, SFID, subframe_data = struct.unpack('>BB30s', data)
        bs = bitstream.BitStream(subframe_data)
        if SFID == 4:
            TLM = bs.read(22)
            TLM_C = bs.read(2)
            HOW = bs.read(22)
            t = bs.read(2)
            
            data_id = bs.read(2)
            sv_id = bs.read(6)
            
            if sv_id == 56: # page 18
                alpha = [
                    bs.read_signed(8) * 2**-30,
                    bs.read_signed(8) * 2**-27,
                    bs.read_signed(8) * 2**-24,
                    bs.read_signed(8) * 2**-24,
                ]
                beta = [
                    bs.read_signed(8) * 2**11,
                    bs.read_signed(8) * 2**14,
                    bs.read_signed(8) * 2**16,
                    bs.read_signed(8) * 2**16,
                ]
                A_1 = bs.read_signed(24) * 2**-50
                A_0 = bs.read_signed(32) * 2**-30
                t_ot = bs.read(8) * 2**12
                WN_t = bs.read(8)
                Deltat_LS = bs.read_signed(8)
                WN_LSF = bs.read(8)
                DN = bs.read(8)
                Deltat_LSF = bs.read_signed(8)
                reserved = bs.read(14)
                t = bs.read(2)
                assert bs.at_end()
                
                self.ionospheric_model = gps.IonosphericModel(alpha, beta)


rospy.init_node('skytraq_parser')

handlers = Handlers(rospy.get_param('~frame_id'))

import threading
l = threading.Lock()
def got_serial(msg):
    with l:
        protocol.dispatch(msg.payload, handlers, stamp=msg.header.stamp)
rospy.Subscriber('skytraq_serial', SerialPacket, got_serial)

rospy.spin()

#!/usr/bin/python

from __future__ import division

import struct

import numpy

import roslib
roslib.load_manifest('skytraq_driver')
import rospy
from std_msgs.msg import Header
from geometry_msgs.msg import Vector3, PointStamped, Point

from rawgps_common import gps, bitstream
from rawgps_common.msg import Measurements, Satellite
from skytraq_driver import protocol
from skytraq_driver.msg import Packet, PacketSet


class Handlers(object):
    def __init__(self, frame_id):
        self.frame_id = frame_id
        
        self.ionospheric_model = None
        self.last_meas_time = None
        self.position = None
        self.ephemerises = {}
        self.pub = rospy.Publisher('gps', Measurements)
        self.pos_pub = rospy.Publisher('~pos', PointStamped)
        
        self.ephemeris_data = {} # prn -> (iode -> [frame*3])
    
    def gps_ephemeris_data(self, data, stamp):
        sv, = struct.unpack('>H', data[0:2])
        if all(x == '\x00' for x in data[3:]):
            #assert False # XXX
            return
        
        subframes = ['\x00'*3 + data[2+1+28*i:2+1+28*i+27] for i in xrange(3)]
        
        for i, subframe in enumerate(subframes):
            self.subframe(chr(sv) + chr(i+1) + subframe, stamp=stamp)
        self._ephemeris_think(sv, gps.Subframe1(subframes[0][3:]).IODE)
        assert len(data) == 2+1+28*2+27, len(data)
    
    def ack(self, data, stamp):
        pass
    
    def sv_ch_status(self, data, stamp):
        pass
    
    def meas_time(self, data, stamp):
        IOD, WN, TOW_ms, measurement_period_ms = struct.unpack('>BHIH', data)
        self.last_meas_time = IOD, gps.Time(WN, TOW_ms*1e-3)
    
    def raw_meas(self, data, stamp):
        print
        iod, nmeas = struct.unpack('>BB', data[0:2])
        assert len(data) == 2+nmeas*23
        measurements = [struct.unpack('>BBddfB', data[2+i*23:2+i*23+23])
            for i in xrange(nmeas)]
        
        if self.last_meas_time is None or self.last_meas_time[0] != iod:
            print "IOD didn't match!"
            return
        t = self.last_meas_time[1]
        
        #print nmeas, 'SATELLITES'
        if self.position is None:
            print '   ', 'NO FIX'
            return
        
        msg = Measurements(
            header=Header(
                stamp=stamp,
                frame_id=self.frame_id,
            ),
            satellites=[],
        )
        #print
        #print
        #print
        #print
        #print
        for prn, cn0, pseudorange, acc_carrier_cycle, doppler_freq, status in measurements:
            (pseudorange_avail, doppler_freq_avail, acc_carrier_cycle_avail,
                cycle_slip_possible, integration_time_greater_10ms) = [
                bool(status & 2**i) for i in xrange(5)]
            if not pseudorange_avail:
                pseudorange = None
            if not doppler_freq_avail:
                doppler_freq = None
            if not acc_carrier_cycle_avail:
                acc_carrier_cycle = None
            
            print prn, cn0, pseudorange, acc_carrier_cycle, doppler_freq
            
            if doppler_freq is None:
                print 'no doppler frequency, dropping', prn
                continue
            
            if prn not in self.ephemerises:
                print 'no ephemeris, dropping', prn
                continue
            eph = self.ephemerises[prn]
            if not eph.is_healthy():
                print 'unhealthy, dropping', prn
                continue
            
            sat_msg = gps.generate_satellite_message(
                prn, eph, cn0, t,
                pseudorange, acc_carrier_cycle, doppler_freq,
                self.position, self.ionospheric_model)
            if sat_msg is not None:
                msg.satellites.append(sat_msg)
        print len(msg.satellites), 'GOOD SATELLITES'
        self.pub.publish(msg)
    
    def rcv_state(self, data, stamp):
        iod, navigation_state, wn, tow, ecef_x, ecef_y, ecef_z, ecef_dx, ecef_dy, ecef_dz, clock_bias, clock_drift, gdop, pdop, hdop, vdop, tdop = struct.unpack('>BBHddddfffdffffff', data)
        
        if navigation_state < 0x02:
            return
        
        self.position = numpy.array([ecef_x, ecef_y, ecef_z])
        
        self.pos_pub.publish(PointStamped(
            header=Header(
                stamp=stamp,
                frame_id='/ecef',
            ),
            point=Point(ecef_x, ecef_y, ecef_z),
        ))
    
    def subframe(self, data, stamp):
        PRN, SFID, subframe_data = struct.unpack('>BB30s', data)
        
        if SFID in [1, 2, 3]:
            subframe = gps.subframes[SFID](subframe_data[3:])
            self.ephemeris_data.setdefault(PRN, {}).setdefault(subframe.IODE, [None]*3)[SFID-1] = subframe
            self._ephemeris_think(PRN, subframe.IODE)
        elif SFID == 4:
            subframe = gps.Subframe4(subframe_data[3:])
            if subframe.sv_id == 56: # page 18
                self.ionospheric_model = gps.IonosphericModel(subframe.alpha, subframe.beta)
    
    def _ephemeris_think(self, prn, iode):
        subframes = self.ephemeris_data[prn][iode]
        if any(x is None for x in subframes): return
        self.ephemerises[prn] = gps.Ephemeris(*subframes)
        


rospy.init_node('skytraq_parser')

handlers = Handlers(rospy.get_param('~frame_id'))

import threading
l = threading.Lock()

last_persistent = set()
def got_persistent(packetset):
    global last_persistent
    with l:
        for packet in sorted(packetset.packets, key=lambda packet: packet.header.stamp):
            if (packet.id, packet.data) not in last_persistent:
                protocol.dispatch(packet.id, packet.data, handlers, stamp=packet.header.stamp)
        last_persistent = set([(packet.id, packet.data) for packet in packetset.packets])
rospy.Subscriber('skytraq_serial/persistent', PacketSet, got_persistent)

def got_ephemeral(packet):
    with l:
        protocol.dispatch(packet.id, packet.data, handlers, stamp=packet.header.stamp)
rospy.Subscriber('skytraq_serial/ephemeral', Packet, got_ephemeral)

rospy.spin()

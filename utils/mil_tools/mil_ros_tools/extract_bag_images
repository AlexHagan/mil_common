#!/usr/bin/env python

"""
Converts bags to labelme images, or labelme annotations to bags.

Uses a YAML file to specify what times and topics in a set of bag files
will be used to extract images for labeling. These images will be placed
in the correct folder to be displayed in the LabelMe web interface.

Once images are labeled, run this command again with --inject-annotations
to parse the labeled images and inject them as a ros message into a new bag file.

With the -r flag, a report will be generated based on the specified YAML
about how many images are labeled in LabelMe. If this returns 100%,
all images generated from the bag are now labeled and can be injected
back into a bag.

"""
from __future__ import division
import argparse
import yaml
import xml.etree.ElementTree
import os
import rospy
import rosbag
import cv2
from sensor_msgs.msg import CameraInfo
from image_geometry import PinholeCameraModel
from cv_bridge import CvBridge
from geometry_msgs.msg import Point
from mil_msgs.msg import LabeledObjects, LabeledObject
from mil_vision_tools.image_proc import Processor, ImageSet
from cv_bridge.boost.cv_bridge_boost import cvtColor2


class BagImageExtractor(object):
    '''
    Stores the configuration for one bag to label.
    '''
    MONO = 'mono'
    COLOR = 'color'
    RECT = 'rect'
    RECT_COLOR = 'rect_color'
    RAW = 'raw'
    def __init__(self, filename, topic, start=None, stop=None, freq=None, images=None, encoding=None):
        '''
        @param filename: name of bag file. Can be an absolute path, or will be resolved relative
                         to specified dir when
        @param topic: topic in the bag file with the images you wish to extract
        @param start: time relative to start of bag to begin extracting images from.
                      If None, extraction will start at beginning of bag
        @param stop: time relative to start of bag to stop extracting images from.
                     If None, extraction wil end at end of bag.
        @param freq: Number of images to extract for each second of bag time.
                     If None, include all images
        @param encoding: Specifies if color conversion or distortion rectification should be applied.
                         If None, images will be saved in the same format they are in the specified topic.
                         If 'mono', image will be converted to grayscale from color or bayer image
                         If 'color', image will be converted to color from bayer.
                         If 'rect', image will be converted to grayscale and rectified using camera info
                         If 'rect_color', image will be converted to color and rectified using camera info
        '''
        self.filename = filename
        self.topic = topic
        self.start = start
        self.stop = stop
        self.freq = freq
        self.encoding = self.get_image_proc_flags_from_encoding(encoding)
        self.image_set = ImageSet()

    @staticmethod
    def get_image_proc_flags_from_encoding(encoding):
        if encoding == None or encoding == BagImageExtractor.RAW:
            return Processor.RAW
        elif encoding == BagImageExtractor.MONO:
            return Processor.MONO
        elif encoding == BagImageExtractor.RECT:
            return Processor.RECT
        elif encoding == BagImageExtractor.COLOR:
            return Processor.COLOR
        elif encoding == BagImageExtractor.RECT_COLOR:
            return Processor.RECT_COLOR
        else:
            raise Exception('invalid encoding {}'.format(encoding))

    @classmethod
    def from_dict(cls, d):
        if not isinstance(d, dict):
            raise Exception('must be dict')
        if 'file' not in d:
            raise Exception('dict must contain a file')
        if 'topic' not in d:
            raise Exception('dict must contain a topic')
        return cls(d['file'], d['topic'], start=d.get('start'), stop=d.get('stop'),
                   freq=d.get('freq'), images=d.get('images'), encoding=d.get('encoding'))

    @staticmethod
    def get_camera_model(bag, topic):
        topic_root = topic.rsplit('/', 1)[0]
        camera_info_topic = topic_root + '/' + 'camera_info'
        try:
            _, msg, _ = bag.read_messages(topics=camera_info_topic).next()
        except StopIteration:
            raise Exception('no camera info messages found in {}'.format(camera_info_topic))
        if msg._type != 'sensor_msgs/CameraInfo':
            raise Exception('msg on topic {} are not camera info'.format(camera_info_topic))
        model = PinholeCameraModel()
        model.fromCameraInfo(msg)
        return model

    def _save_img(self, msg, time, image_dir):
        Processor.process(msg, self.camera_model, self.image_set, self.encoding)
        if self.encoding == 0:
            img = self.image_set.raw
        elif self.encoding == Processor.MONO:
            img = self.image_set.mono
        elif self.encoding == Processor.RECT:
            img = self.image_set.rect
        elif self.encoding == Processor.COLOR:
            img = self.image_set.color
        elif self.encoding == Processor.RECT_COLOR:
            img = self.image_set.rect_color

        # If color, convert to bgr
        if self.encoding == Processor.COLOR or self.encoding == Processor.RECT_COLOR:
            img = cvtColor2(img, self.image_set.color_encoding, 'bgr8')
        filename = os.path.join(image_dir, str(msg.header.stamp) + '.png')
        cv2.imwrite(filename, img)

    def extract_images(self, image_dir='.', bag_dir='.'):
        filename = os.path.join(bag_dir, self.filename)
        b = rosbag.Bag(filename)
        if self.encoding != 0:
            self.camera_model = self.get_camera_model(b, self.topic)
        else:
            self.camera_model = None
        _, _, first_time = b.read_messages().next()
        start = first_time + rospy.Duration(self.start) if self.start else first_time
        stop = first_time + rospy.Duration(self.stop) if self.stop else None
        interval = rospy.Duration(1.0 / self.freq) if self.freq else rospy.Duration(0)
        next_time = start
        for _, msg, time in b.read_messages(topics=self.topic, start_time=start, end_time=stop):
            if time >= next_time:
                next_time = time + interval
                self._save_img(msg, time, image_dir)

class BagsProjectImageExtractor(object):
    def __init__(self, bag_configs, bag_dir=None, image_dir=None):
        self.bags = bag_configs
        self.bag_dir = bag_dir if bag_dir is not None else '.'
        self.image_dir = image_dir if image_dir is not None else '.'

    @classmethod
    def from_dict(cls, d):
        if not isinstance(d, dict):
            raise Exception('must be dict')
        if 'bags' not in d:
            raise Exception('yaml must contain a list of bags. See example.')
        bags = []
        for bag in d['bags']:
            bags.append(BagImageExtractor.from_dict(bag))
        return cls(bags, bag_dir=d.get('bag_dir'), image_dir=d.get('image_dir'))

    def run(self):
        for bag in self.bags:
            bag.extract_images(bag_dir=self.bag_dir, image_dir=self.image_dir)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Generates rosbags based on LabelMe data and visa/versa')
    parser.add_argument('config', type=str,
                        help='YAML file specifying what bags to read and extract images from.\
                              See example YAML for details')
    parser.add_argument('--bag-dir', '-b', dest="bag_dir", type=str, default=None,
                        help="directory to resolve relative paths specifed in YAML for input bags. \n\
                              Defaults to current directory.")
    parser.add_argument('--image-dir', '-o', dest="image_dir", type=str, default=None,
                        help="directory to resolve relative paths specified in YAML for output (labeled) bags. \n\
                              Defaults to current directory.")
    parser.add_argument('--verbose', '-v', dest='verbose', action='store_true',
                        help='Print extra information about what the script is doing')
    args = parser.parse_args()

    config_file = open(args.config)
    config = yaml.load(config_file)
    if not isinstance(config, dict):
        raise Exception('yaml config should be in dictionary format. See example')

    # Set bag_dir and image_dir from cli args or yaml config or default
    if args.bag_dir is not None:
        config['bag_dir'] = args.bag_dir
    if args.image_dir is not None:
        config['image_dir'] = args.image_dir
    project = BagsProjectImageExtractor.from_dict(config)
    project.run()
